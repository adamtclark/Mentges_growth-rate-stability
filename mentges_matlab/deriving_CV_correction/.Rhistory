rnums = rpoilog(100, 1, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 1, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 0.5, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2, 1, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 4, 2, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 4, 2, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 4, 2, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 4, 2, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 1, 0.5, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2, 0.5, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
rnums = rpoilog(100, 2.5, 2, nu=1, condS=FALSE, keep0=FALSE)
sort(rnums, decreasing = TRUE)
sum(rnums==1)
sum(rnums)
doc rpoilog
help(rpoilog)
x <- sin(1:100)
y <- 1 + x + rnorm(100)
fm <- lm(y ~ x)
vcovHAC(fm)
vcov(fm)
lm(y ~ x)
summary(x <- sin(1:100)
y <- 1 + x + rnorm(100)
fm <- lm(y ~ x)
vcovHAC(fm)
vcov(fm)
lm(y ~ x)
summary(fm)
vcovHAC(fm)
vcov(fm)
library(sandwich)
vcovHAC(fm)
vcov(fm)
help("vcov")
install.packages(c("roxygen2", "devtools"))
load("devtools")
library("devtools")
library("roxygen2")
package.skeleton("shampoo")
a <- arima(lh, order = c(1,0,0))
a
lh
help pnorm
help(pnorm)
aa$coef
aa <- arima(lh, order = c(1,0,0))
aa$coef
(1 - pnorm( abs(0.61466)/0.299 )   )*2
pnorm( abs(0.61466)/0.299 )   )
pnorm( abs(0.61466)/0.299    )
load(poilog)
library(poilog)
help rpoilog
help(rpoilog)
rpoilog(2,0.5,4)
rpoilog(2,0.5,4)
rpoilog(2,0.5,4)
rpoilog(2,0.5,4)
rpoilog(2,0.5,4)
rpoilog(2,0.5,4)
rpoilog(2,0.5,4)
rpoilog(2,0.5,10)
rpoilog(10, 2, 0.5)
rpoilog(10, 2, 0.5)
rpoilog(10, 2, 0.5)
rpoilog(10, 2, 0.5)
rpoilog(10, 2, 0.5)
rpoilog(10, 2, 0.5)
rpoilog(10, 2, 0.5)
getAnywhere(rpoilog)
doc rnorm
help(rnorm)
help(rpois)
rnorm(3)
rnorm(3)
rnorm(3)
rnorm(3)
Stot = 3
lamx = rnorm(Stot)
help(rpoilog)
mu = 2
sig = 0.5
Stot = 3
sampling_intensity = 1
lamx = rnorm(Stot)
lamx
exp(sig * lamx + mu + log(sampling_intensity)
)
rpois(Stot, exp(sig * lamx + mu + log(sampling_intensity)))
x <- rpois(Stot, exp(sig * lamx + mu + log(sampling_intensity)))
help(rpois)
help(rnorm)
lamx = rnorm(Stot)
lamx
help(exp)
exp(1)
citation(rpoilog)
library(poilog)
library(poilog)
citation(rpoilog)
citation()
citation("rpoilog")
citation("poilog")
getAnywhere(rpoilog)
library(poilog)
getAnywhere(rpoilog)
library(robis)
library(ggplot2)
library(dplyr)
data <- occurrence("Abra alba")
data <- occurrence(aphiaid = 141433)
datasets <- dataset(seq(2500, 2520))
library(robis)
library(ggplot2)
library(dplyr)
install.packages("devtools")
install.packages("devtools")
library(devtools)
install_github("iobis/robis")
library(devtools)
library(robis)
install_github("iobis/robis")
library(robis)
install.packages(c("boot", "bridgesampling", "broom", "checkmate", "class", "clipr", "cluster", "coda", "codetools", "cowplot", "crul", "data.table", "dbplyr", "DHARMa", "doParallel", "evaluate", "forcats", "foreach", "foreign", "gap", "geosphere", "ggmap", "git2r", "gmm", "haven", "highr", "hms", "iterators", "jpeg", "KernSmooth", "knitr", "lmtest", "MASS", "Matrix", "matrixStats", "mgcv", "modelr", "mvtnorm", "nlme", "numDeriv", "oai", "pbapply", "plotrix", "pracma", "progress", "qrnn", "R.oo", "R.utils", "RcppEigen", "readxl", "reprex", "rgbif", "rgeos", "RgoogleMaps", "rmarkdown", "roxygen2", "rpart", "rstan", "rstudioapi", "rvest", "sandwich", "selectr", "sfsmisc", "spaMM", "StanHeaders", "survival", "tidyverse", "tinytex", "urltools", "whisker", "worrms", "xml2", "zoo"))
R.version.string
install.packages(c("boot", "foreign", "KernSmooth", "Matrix", "mgcv", "nlme", "survival"))
library(devtools)
install.packages("devtools")
library(devtools)
install_github("iobis/robis")
library(robis)
data <- occurrence("Abra alba")
datasets <- dataset(seq(2500, 2520))
crete <- occurrence(resourceid = 3185)
library(c("geiger", "gstat", "plotrix", "wrswoR"))
# # Install packages (only the first time, not needed after this)
# install.packages(c("Rcpp", "rJava", "geiger", "gstat", "plotrix", "wrswoR"))
# Load packages to library
library("geiger")
library("gstat")
library("plotrix")
library("wrswoR")
# Landscape parameters
grid.side <- 21 # number of cells in each side of the quadrangular grid
R <- 30 # regional species pool (number of species)
J <- 0.80 # initial proportion of occupied cells
N_env <- 1 # number of environmental variables
sp_distr <- "random" # initial distribution of species across landscape is random
cor_env <- 20 # variogram range parameter (spatial correlation in the environment)
# between 1 and grid.side
# 1 will make it almost random
# grid side will make it strongly auto-correlated
# Model parameters
D <- 0.01 # mortality rate
M <- 0.5 # productivity (proportion of individuals reproducing)
Z <- 10 # number of dispersed propagules per individual
kern.type <- "lnorm" # lognormal dispersal kernel
sd.disp <- 0.7 # dispersal capacity (log SD of lognormal kernel)
sd.niche <- 10 # niche breadth (SD of normal distribution)
G = 1000 # number of time steps (generation times)
# Initialize species
set.seed(49)
spi <- sp.set(grid.side=grid.side, R=R, Ji=J, N_env=N_env, evolve=FALSE, sp.distr=sp_distr)
# Initialize environment
set.seed(79)
envi <- env.set(grid.side=grid.side,R=R,Nenv=N_env,type="mosaic",
cor.range=cor_env, Nsamples=50)
# set.seed(1)
# envi <- env.set(grid.side=grid.side,R=R,Nenv=N_env,type="mosaic",
#                 cor.range=cor_env, Nsamples=50)
# set.seed(2)
# envi <- env.set(grid.side=grid.side,R=R,Nenv=N_env,type="mosaic",
#                 cor.range=cor_env, Nsamples=50)
# Extract useful values
xy <- envi$xy
coords2 <- as.data.frame(envi$coords)
opt2 <- spi$opt
yy.data <- as.data.frame(envi$yy.data[,1:N_env])
# Run model
#================================================================================
# Run simulation
set.seed(77)
sp.ini <- spatcom(sp.i=spi,env.i=envi,D=D,M=M,Z=Z,kern.type=kern.type,
peak.disp=0,sd.disp=sd.disp,sd.niche=sd.niche,meta.type="SS",G=G)
# What does this generate and what is in it???????????????
# View(sp.ini)
# Show results
par(mfrow=c(2,1),mar=c(4,4,2,2))
curve(dnorm(x,10,1),from=0,to=30,lwd=2,col="darkcyan",xlab="Environment",ylab="Probability")
curve(dnorm(x,20,1),from=0,to=30,lwd=2,add=T,col="orange")
curve(dnorm(x,10,20),from=0,to=30,lwd=2,col="darkcyan",xlab="Environment",ylab="Probability")
curve(dnorm(x,20,20),from=0,to=30,lwd=2,add=T,col="orange")
curve(dnorm(x,10,1), from=0,to=30,lwd=2,col="darkcyan",xlab="Environment",ylab="Probability",title="test")
par(mfrow=c(2,1),mar=c(4,4,2,2))
curve(dnorm(x,10,1), from=0,to=30,lwd=2,col="darkcyan",xlab="Environment",ylab="Probability")
curve(dnorm(x,20,1), from=0,to=30,lwd=2,add=T,col="orange")
curve(dnorm(x,10,20),from=0,to=30,lwd=2,col="darkcyan",xlab="Environment",ylab="Probability")
curve(dnorm(x,20,20),from=0,to=30,lwd=2,add=T,col="orange")
curve(dnorm(x,10,sd.niche), from=0,to=30,lwd=2,col="darkcyan",xlab="Environment",ylab="Probability")
curve(dnorm(x,20,sd.niche), from=0,to=30,lwd=2,add=T,col="orange")
seq(1,5)
for mu in seq(0.5, R-0.5, 1){
curve(dnorm(x, 10, sd.niche), from=0,to=30,lwd=2,col="darkcyan",xlab="Environment",ylab="Probability")
}
for mu in seq(0.5, R-0.5, 1){
add
curve(dnorm(x, 10, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
}
for mu in seq(0.5, R-0.5, 1){
par(new=FALSE)
curve(dnorm(x, 10, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
}
for mu in seq(0.5, R-0.5, 1){
par(new=FALSE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
}
par(new=FALSE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
mu = 5
par(new=FALSE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
mu = 3
par(new=TRUE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
for mu in seq(0.5, R-0.5, 1){
par(new=TRUE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
}
for (mu in seq(0.5, R-0.5, 1)){
par(new=TRUE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
}
for (mu in seq(0.5, R-0.5, 1)){
par(new=TRUE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
}
# Plot niche axis FIND OUT: HOW LONG IS THE GRADIENT? HOW MANY SPECIES?
for (mu in seq(0.5, R-0.5, 1)){
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
par(new=TRUE)
}
par(new=FALSE)
# Final picture - environment
sp.distr <- SpatialPixelsDataFrame(coordinates(xyf),as.data.frame(yyf))
spplot(sp.distr)
par(new=FALSE)
curve(dnorm(x, 0.5, sd.niche), from=0, to=30, lwd=2, col="darkcyan", xlab="Environment", ylab="Probability")
for (mu in seq(0.5, R-0.5, 1)){
par(new=TRUE)
curve(dnorm(x, mu, sd.niche), from=0, to=30, lwd=2, col="darkcyan")
}
par(new=FALSE)
install.packages("swirl")
install.packages("swirl")
install.packages("swirl")
install.packages("swirl")
# # install.packages("swirl")
load("swirl")
install.packages("swirl")
load.package("swirl")
# # install.packages("swirl")
library("swirl")
swirl()
swirl
swirl()
swirl()
swirl()
# # install.packages("swirl")
library("swirl")
swirl()
swirl()
swirl()
bye()
install_from_swirl("Exploratory Data Analysis")
swirl()
str(mpg)
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
swirl()
skip()
play()
qplot(displ, hwy, data = mpg, geom=c("point", "smooth"),facets=.~drv)
qplot(displ, hwy, data = mpg, geom=c("point", "smooth"),facets=drv~.)
nxt()
skip()
summary(g)
g+geom_point()
rpoilog
library("poilog")
install.packages("poilog")
library("poilog")
getAnywhere(rpoilog)
version()
ver()
R.Version()
debugSource('~/Nextcloud/Project_III/CV_correction/functions_Adam.R')
setwd("/Users/am41xite/Nextcloud/Project_III/CV_correction")
source("functions_Adam.R")
rlst<-seq(1,2, length=20)
varout<-numeric(length(rlst))
cvout<-numeric(length(rlst))
K<-10
for(i in 1:length(rlst)) {
#               f:1/lambda  d:mu d_sd: sigma
d<-symdyn(r=rlst[i], f=2, d=0, d_sd=0.1, sf=0.1, tmax=100, stochd = TRUE, stocht = TRUE, as.matrix = TRUE)
x<-d[d[,"time"]>20,"state"]
t<-d[d[,"time"]>20,"time"]
N<-x+K
varout[i]<-var(N)
cvout[i]<-sd(N)/mean(N)
}
plot(rlst , varout)
mu<-0
sigma<-0.1
lambda<-0.5
source('~/Nextcloud/Project_III/CV_correction/script_Adam.R')
for(i in 1:length(rlst)) {
#               f:1/lambda  d:mu d_sd: sigma
d<-symdyn(r=rlst[i], f=2, d=0, d_sd=0.1, sf=0.1, tmax=100, stochd = TRUE, stocht = TRUE, as.matrix = TRUE)
x<-d[d[,"time"]>20,"state"]
t<-d[d[,"time"]>20,"time"]
N<-x+K
varout[i]<-var(N)
cvout[i]<-sd(N)/mean(N)
}
debugSource('~/Nextcloud/Project_III/CV_correction/functions_Adam.R')
for(i in 1:length(rlst)) {
#               f:1/lambda  d:mu d_sd: sigma
d<-symdyn(r=rlst[i], f=2, d=0, d_sd=0.1, sf=0.1, tmax=100, stochd = TRUE, stocht = TRUE, as.matrix = TRUE)
x<-d[d[,"time"]>20,"state"]
t<-d[d[,"time"]>20,"time"]
N<-x+K
varout[i]<-var(N)
cvout[i]<-sd(N)/mean(N)
}
st<-seq(0, tmax, by=sf)
st
nobs<-length(st)
nobs
datout<-matrix(nrow=length(st), ncol=3)
colnames(datout)<-c("time", "state", "disturbed")
datout[,"time"]<-st
datout[1,"state"]<-0
datout[,"disturbed"]<-0
x<-0 #standardized abundance
tm<-0 #time
n<-2 #sample position
md<-1 #number of disturbances
tsamp<-st[n]
tdist<-tm+rexp(1, 1/f) #time to next disturbance
tsamp<-st[n]
st<-seq(0, tmax, by=sf)
nobs<-length(st)
datout<-matrix(nrow=length(st), ncol=3)
colnames(datout)<-c("time", "state", "disturbed")
datout[,"time"]<-st
datout[1,"state"]<-0
datout[,"disturbed"]<-0
x<-0 #standardized abundance
tm<-0 #time
n<-2 #sample position
md<-1 #number of disturbances
if(stocht) {
tdist<-tm+rexp(1, 1/f) #time to next disturbance
} else {
tdist<-tm+f
}
tsamp<-st[n]
x<-xt(tm, tdist, x, r)
tm
tdist
debugSource('~/Nextcloud/Project_III/CV_correction/functions_Adam.R')
#               f:1/lambda  d:mu d_sd: sigma sf:stepwidth
d<-symdyn(r=rlst[i], f=2, d=0, d_sd=0.1, sf=0.1, tmax=100, stochd = TRUE, stocht = TRUE, as.matrix = TRUE)
x<-d[d[,"time"]>20,"state"]
t<-d[d[,"time"]>20,"time"]
N<-x+K
varout[i]<-var(N)
cvout[i]<-sd(N)/mean(N)
tm
tdist
x
r
tm<-tdist
x
x<-xt(tm, tdist, x, r)
x
rd<-rnorm(1, d, d_sd)
x<-x+rd
datout[n,"disturbed"]<-datout[n,"disturbed"]+1
datout
if(stocht) {
tdist<-tm+rexp(1, 1/f) #time to next disturbance
} else {
tdist<-tm+f
}
}
}
if(!as.matrix) {
data.frame(datout)
} else {
datout
}
}
datout
#               f:1/lambda  d:mu d_sd: sigma sf:stepwidth
d<-symdyn(r=rlst[i], f=2, d=0, d_sd=0.1, sf=0.1, tmax=100, stochd = TRUE, stocht = TRUE, as.matrix = TRUE)
x<-d[d[,"time"]>20,"state"]
t<-d[d[,"time"]>20,"time"]
N<-x+K
varout[i]<-var(N)
cvout[i]<-sd(N)/mean(N)
d
